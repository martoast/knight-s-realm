This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-25T23:07:32.430Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
js/
  animation.js
  combat.js
  enemy.js
  inventory.js
  main.js
  player.js
  ui.js
  utils.js
  world.js
index.html
styles.css

================================================================
Repository Files
================================================================

================
File: js/animation.js
================
// animation.js - Completely rewritten file
class Animation {
    constructor(spritesheet, frameCount, frameDuration, loop = true) {
        // Store reference to the spritesheet data
        this.spritesheet = spritesheet;
        // How many frames are in this animation
        this.frameCount = frameCount;
        // How long each frame should display (in ms)
        this.frameDuration = frameDuration;
        // Should the animation loop?
        this.loop = loop;
        // Current frame index
        this.frameIndex = 0;
        // Time tracking for frame changes
        this.timeSinceLastFrame = 0;
        // Track if non-looping animation is complete
        this.finished = false;
        // Store animation name for debugging
        this.name = '';
    }
  
    update(deltaTime) {
        // If animation is finished and doesn't loop, do nothing
        if (this.finished && !this.loop) return;
  
        // Accumulate time since last update
        this.timeSinceLastFrame += deltaTime;
  
        // Check if it's time to move to the next frame
        if (this.timeSinceLastFrame >= this.frameDuration) {
            // Move to next frame
            this.frameIndex++;
            
            // Reset time counter
            this.timeSinceLastFrame = 0;
            
            // Handle animation completion
            if (this.frameIndex >= this.frameCount) {
                if (this.loop) {
                    // Loop back to first frame
                    this.frameIndex = 0;
                } else {
                    // Stay on last frame and mark as finished
                    this.frameIndex = this.frameCount - 1;
                    this.finished = true;
                }
            }
        }
    }
  
    draw(ctx, x, y, flipX = false) {
        // Ensure valid frame index - critical for jump animation with 6 frames
        const frameIndex = Math.min(Math.max(0, this.frameIndex), this.frameCount - 1);
        
        // Get frame dimensions
        const frameWidth = this.spritesheet.frameWidth;
        const frameHeight = this.spritesheet.frameHeight;
        
        // Calculate the source position in the spritesheet
        // Make sure we select the correct frame in the strip
        const sourceX = Math.floor(frameIndex * frameWidth);
        const sourceY = 0; // All frames are in a single row
        
        // Save context state before applying transformations
        ctx.save();
        
        if (flipX) {
            // Set up horizontal flip transformation
            ctx.translate(x + frameWidth, y);
            ctx.scale(-1, 1);
            
            try {
                // Draw the frame - wrap in try/catch to handle any drawing errors
                ctx.drawImage(
                    this.spritesheet.image,   // Image source
                    sourceX, sourceY,         // Source position
                    frameWidth, frameHeight,  // Source dimensions
                    0, 0,                     // Destination position (0,0 because of translation)
                    frameWidth, frameHeight   // Destination dimensions
                );
            } catch (error) {
                console.error(`Error drawing animation frame: ${error.message}`);
                console.error(`Frame: ${frameIndex}/${this.frameCount}, Source: (${sourceX}, ${sourceY}), Size: ${frameWidth}x${frameHeight}`);
            }
            
            // Debug visualization
            if (window.DEBUG_SHOW_FRAMES) {
                // Frame boundary
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, frameWidth, frameHeight);
                
                // Frame number
                ctx.fillStyle = 'yellow';
                ctx.font = '12px Arial';
                ctx.fillText(`Frame: ${frameIndex+1}/${this.frameCount}`, 5, 15);
                
                if (this.name) {
                    ctx.fillText(this.name, 5, 30);
                }
            }
        } else {
            // Draw the frame normally
            try {
                ctx.drawImage(
                    this.spritesheet.image,   // Image source
                    sourceX, sourceY,         // Source position
                    frameWidth, frameHeight,  // Source dimensions
                    x, y,                     // Destination position
                    frameWidth, frameHeight   // Destination dimensions
                );
            } catch (error) {
                console.error(`Error drawing animation frame: ${error.message}`);
                console.error(`Frame: ${frameIndex}/${this.frameCount}, Source: (${sourceX}, ${sourceY}), Size: ${frameWidth}x${frameHeight}`);
            }
            
            // Debug visualization
            if (window.DEBUG_SHOW_FRAMES) {
                // Frame boundary
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, frameWidth, frameHeight);
                
                // Frame number
                ctx.fillStyle = 'yellow';
                ctx.font = '12px Arial';
                ctx.fillText(`Frame: ${frameIndex+1}/${this.frameCount}`, x + 5, y + 15);
                
                if (this.name) {
                    ctx.fillText(this.name, x + 5, y + 30);
                }
            }
        }
        
        // Restore the context state
        ctx.restore();
    }
  
    reset() {
        this.frameIndex = 0;
        this.timeSinceLastFrame = 0;
        this.finished = false;
    }
}
  
class AnimationManager {
    constructor() {
        this.animations = {};
        this.currentAnimation = null;
        this.previousAnimation = null;
        this.locked = false; // Add a lock to prevent animation switching
    }
  
    addAnimation(name, animation) {
        animation.name = name; // Store name in animation for debugging
        this.animations[name] = animation;
    }
  
    playAnimation(name) {
        // Don't change animations if locked (prevents interruptions)
        if (this.locked) return;
        
        // Check if animation exists
        if (!this.animations[name]) {
            console.error(`Animation "${name}" not found`);
            return;
        }
  
        // Don't restart the same animation unless it's finished
        if (this.currentAnimation === name) {
            if (this.animations[name].finished) {
                this.animations[name].reset();
            }
            return;
        }
  
        // Store previous animation name
        this.previousAnimation = this.currentAnimation;
  
        // Reset the animation we're switching to
        this.animations[name].reset();
  
        // Set current animation
        this.currentAnimation = name;
        
        // Debug output
        if (window.DEBUG_SHOW_FRAMES) {
            console.log(`Animation changed to: ${name}`);
        }
    }
  
    lockAnimation() {
        this.locked = true;
    }
    
    unlockAnimation() {
        this.locked = false;
    }
    
    update(deltaTime) {
        // Update current animation
        if (this.currentAnimation && this.animations[this.currentAnimation]) {
            this.animations[this.currentAnimation].update(deltaTime);
            
            // If non-looping animation finished and we're locked, unlock
            if (this.locked && this.animations[this.currentAnimation].finished) {
                this.unlockAnimation();
            }
        }
    }
  
    draw(ctx, x, y, flipX = false) {
        // Draw current animation
        if (this.currentAnimation && this.animations[this.currentAnimation]) {
            this.animations[this.currentAnimation].draw(ctx, x, y, flipX);
        }
    }
  
    isFinished() {
        if (this.currentAnimation && this.animations[this.currentAnimation]) {
            return this.animations[this.currentAnimation].finished;
        }
        return true;
    }
  
    getCurrentAnimationName() {
        return this.currentAnimation;
    }
  
    resetCurrentAnimation() {
        if (this.currentAnimation && this.animations[this.currentAnimation]) {
            this.animations[this.currentAnimation].reset();
        }
    }
}

================
File: js/combat.js
================
// Simple placeholder combat system
const combat = {
    checkAttacks: function(player, enemies) {
        // No enemies in simplified version, but we'll keep the function for compatibility
        if (!player.isAttacking) return;
        
        // Enhanced debug info for attack animation
        if (window.DEBUG_SHOW_FRAMES) {
            const attackAnim = player.animationManager.animations['attack'];
            if (attackAnim) {
                console.log(`Attack in progress! Frame: ${attackAnim.frameIndex + 1}/${attackAnim.frameCount} - Time: ${attackAnim.timeSinceLastFrame}ms`);
            }
        }
    },
    
    checkCollision: function(rect1, rect2) {
        return (
            rect1.x < rect2.x + rect2.width &&
            rect1.x + rect1.width > rect2.x &&
            rect1.y < rect2.y + rect2.height &&
            rect1.y + rect1.height > rect2.y
        );
    }
};

================
File: js/enemy.js
================
class Enemy {
  constructor(x, y, type, level) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.level = level || 1;
    this.width = 48;
    this.height = 48;
    this.speed = 1 + level * 0.2;
    this.direction = Math.random() < 0.5 ? -1 : 1;
    this.movementTimer = 0;
    this.movementDuration = utils.randomInt(1000, 3000);
    this.idleTimer = 0;
    this.idleDuration = utils.randomInt(500, 1500);
    this.isIdle = false;
    this.isAttacking = false;
    this.isTakingDamage = false;

    // Stats
    this.maxHealth = 30 + level * 20;
    this.health = this.maxHealth;
    this.damage = 5 + level * 3;
    this.defense = 2 + level;
    this.experienceValue = 20 + level * 10;

    // Attack cooldown
    this.attackCooldown = 0;
    this.attackCooldownMax = 1000;

    // Animation
    this.animationManager = new AnimationManager();
    this.loadAnimations();

    // AI
    this.detectionRange = 200;
    this.attackRange = 50;

    this.y = Math.floor(this.y);
  }

  async loadAnimations() {
    try {
      // Load animation spritesheets - notice the space in the filenames to match your actual files
      const idleSprite = await utils.loadSpritesheet(
        "sprites/knight/Idle.png",
        64,
        64
      );
      const walkSprite = await utils.loadSpritesheet(
        "sprites/knight/Walk.png",
        64,
        64
      );
      const runSprite = await utils.loadSpritesheet(
        "sprites/knight/Run.png",
        64,
        64
      );
      const jumpSprite = await utils.loadSpritesheet(
        "sprites/knight/Jump.png",
        64,
        64
      );
      const attack1Sprite = await utils.loadSpritesheet(
        "sprites/knight/Attack1.png",
        64,
        64
      ); // Notice the space here
      const attack2Sprite = await utils.loadSpritesheet(
        "sprites/knight/Attack2.png",
        64,
        64
      ); // Notice the space here
      const attack3Sprite = await utils.loadSpritesheet(
        "sprites/knight/Attack3.png",
        64,
        64
      ); // Notice the space here
      const runAttackSprite = await utils.loadSpritesheet(
        "sprites/knight/RunAttack.png",
        64,
        64
      );
      const hurtSprite = await utils.loadSpritesheet(
        "sprites/knight/Hurt.png",
        64,
        64
      );
      const deadSprite = await utils.loadSpritesheet(
        "sprites/knight/Dead.png",
        64,
        64
      );
      const defendSprite = await utils.loadSpritesheet(
        "sprites/knight/Defend.png",
        64,
        64
      );
      const protectSprite = await utils.loadSpritesheet(
        "sprites/knight/Protect.png",
        64,
        64
      );

      // Create animations with appropriate frame counts based on the sprites
      this.animationManager.addAnimation(
        "idle",
        new Animation(idleSprite, 4, 200)
      );
      this.animationManager.addAnimation(
        "walk",
        new Animation(walkSprite, 8, 100)
      );
      this.animationManager.addAnimation(
        "run",
        new Animation(runSprite, 8, 80)
      );
      this.animationManager.addAnimation(
        "jump",
        new Animation(jumpSprite, 2, 200, false)
      );
      this.animationManager.addAnimation(
        "attack1",
        new Animation(attack1Sprite, 5, 100, false)
      );
      this.animationManager.addAnimation(
        "attack2",
        new Animation(attack2Sprite, 5, 100, false)
      );
      this.animationManager.addAnimation(
        "attack3",
        new Animation(attack3Sprite, 5, 100, false)
      );
      this.animationManager.addAnimation(
        "runAttack",
        new Animation(runAttackSprite, 6, 100, false)
      );
      this.animationManager.addAnimation(
        "hurt",
        new Animation(hurtSprite, 2, 200, false)
      );
      this.animationManager.addAnimation(
        "dead",
        new Animation(deadSprite, 6, 200, false)
      );
      this.animationManager.addAnimation(
        "defend",
        new Animation(defendSprite, 2, 200)
      );
      this.animationManager.addAnimation(
        "protect",
        new Animation(protectSprite, 2, 200)
      );

      // Set initial animation
      this.animationManager.playAnimation("idle");
    } catch (error) {
      console.error("Error loading player animations:", error);
    }
  }

  update(deltaTime, player, world) {
    if (!this.isAlive()) {
      this.animationManager.playAnimation("dead");
      this.animationManager.update(deltaTime);
      return;
    }

    // Update cooldown
    if (this.attackCooldown > 0) {
      this.attackCooldown -= deltaTime;
    }

    // Check animation states
    if (this.isAttacking && this.animationManager.isFinished()) {
      this.isAttacking = false;
    }

    if (this.isTakingDamage && this.animationManager.isFinished()) {
      this.isTakingDamage = false;
    }

    // Skip AI if taking damage
    if (this.isTakingDamage) {
      this.animationManager.update(deltaTime);
      return;
    }

    // AI logic
    const distanceToPlayer = utils.distance(this.x, this.y, player.x, player.y);

    // If player is in detection range
    if (distanceToPlayer <= this.detectionRange) {
      // Move towards player
      const playerDirection = player.x < this.x ? -1 : 1;
      this.direction = playerDirection;

      // If in attack range and cooldown is done, attack
      if (distanceToPlayer <= this.attackRange && this.attackCooldown <= 0) {
        this.attack(player);
      } else if (!this.isAttacking) {
        // Move towards player
        this.x += this.speed * this.direction;
        this.animationManager.playAnimation("walk");
      }
    }
    // Random movement when player is not in range
    else {
      if (this.isIdle) {
        this.idleTimer += deltaTime;
        this.animationManager.playAnimation("idle");

        if (this.idleTimer >= this.idleDuration) {
          this.isIdle = false;
          this.movementTimer = 0;
          this.direction = Math.random() < 0.5 ? -1 : 1;
        }
      } else {
        this.movementTimer += deltaTime;
        this.x += this.speed * 0.5 * this.direction;
        this.animationManager.playAnimation("walk");

        if (this.movementTimer >= this.movementDuration) {
          this.isIdle = true;
          this.idleTimer = 0;
          this.idleDuration = utils.randomInt(500, 1500);
        }
      }

      // Check world boundaries
      const bounds = world.getBounds();
      if (this.x < bounds.left || this.x + this.width > bounds.right) {
        this.direction *= -1;
      }
    }

    // Update animation
    this.animationManager.update(deltaTime);
  }

  draw(ctx, cameraX, cameraY) {
    const screenX = this.x - cameraX;
    const screenY = this.y - cameraY;

    // Draw enemy
    this.animationManager.draw(ctx, screenX, screenY, this.direction === -1);

    // Draw health bar
    const healthPercentage = this.health / this.maxHealth;
    const barWidth = this.width;
    const barHeight = 5;

    ctx.fillStyle = "#333";
    ctx.fillRect(screenX, screenY - 10, barWidth, barHeight);

    ctx.fillStyle = "#f00";
    ctx.fillRect(screenX, screenY - 10, barWidth * healthPercentage, barHeight);
  }

  attack(player) {
    this.isAttacking = true;
    this.attackCooldown = this.attackCooldownMax;
    this.animationManager.playAnimation("attack");

    // Deal damage to player when animation is halfway through
    setTimeout(() => {
      if (
        this.isAlive() &&
        utils.distance(this.x, this.y, player.x, player.y) <= this.attackRange
      ) {
        const damageDealt = player.takeDamage(this.damage);
        ui.showMessage(`${this.type} dealt ${damageDealt} damage!`);
      }
    }, this.attackCooldownMax / 2);
  }

  takeDamage(damage) {
    if (!this.isAlive()) return 0;

    const actualDamage = Math.max(1, damage - this.defense);
    this.health -= actualDamage;

    if (this.health <= 0) {
      this.health = 0;
      ui.showMessage(`${this.type} defeated!`);
    } else {
      this.isTakingDamage = true;
      this.animationManager.playAnimation("hurt");
    }

    return actualDamage;
  }

  isAlive() {
    return this.health > 0;
  }

  getXP() {
    return this.experienceValue;
  }

  getHitbox() {
    return {
      x: this.x + 5,
      y: this.y + 5,
      width: this.width - 10,
      height: this.height - 5,
    };
  }
}

================
File: js/inventory.js
================
// Simplified inventory (empty placeholder)
const inventory = {
    init: function(player) {
        // No inventory needed for simplified version
    },
    
    toggleInventory: function() {
        // No inventory in simplified version
        console.log("Inventory disabled in simplified version");
    }
};

================
File: js/main.js
================
// Game state
const gameState = {
    player: null,
    world: null,
    keys: {
        left: false,
        right: false,
        up: false,
        down: false,
        attack: false,
        shift: false
    },
    canvas: null,
    ctx: null,
    lastTime: 0,
    running: false,
    frameCount: 0,
    fps: 0,
    lastFpsUpdateTime: 0
};

// Debug options
window.DEBUG_SHOW_FRAMES = true;  // Set to true to see animation frame boundaries
const FPS_UPDATE_INTERVAL = 500;  // How often to update FPS counter (ms)

// Initialize game
async function initGame() {
    try {
        // Set up canvas
        gameState.canvas = document.getElementById('game-canvas');
        gameState.ctx = gameState.canvas.getContext('2d');
        
        // Set canvas size
        const resizeCanvas = () => {
            gameState.canvas.width = window.innerWidth;
            gameState.canvas.height = window.innerHeight;
        };
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Show loading message
        gameState.ctx.fillStyle = '#000';
        gameState.ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
        gameState.ctx.fillStyle = '#fff';
        gameState.ctx.font = '30px Arial';
        gameState.ctx.textAlign = 'center';
        gameState.ctx.fillText('Loading game...', gameState.canvas.width / 2, gameState.canvas.height / 2);
        gameState.ctx.textAlign = 'left';
        
        // Create world
        gameState.world = new World(5000, 1000);
        
        // Create player at center bottom of screen
        const playerStartX = Math.floor(gameState.canvas.width / 2) - 32;
        const playerStartY = Math.floor(gameState.world.getBounds().bottom) - 64;
        gameState.player = new Player(playerStartX, playerStartY); 
        
        // Initialize UI
        ui.init(gameState.player);
        
        // Set up input handlers
        setupInputHandlers();
        
        // Start game loop
        gameState.running = true;
        gameState.lastTime = performance.now();
        gameState.lastFpsUpdateTime = performance.now();
        requestAnimationFrame(gameLoop);
        
        // Show instructions
        const instructions = document.createElement('div');
        instructions.style.position = 'absolute';
        instructions.style.top = '10px';
        instructions.style.left = '10px';
        instructions.style.background = 'rgba(0,0,0,0.7)';
        instructions.style.color = 'white';
        instructions.style.padding = '15px';
        instructions.style.borderRadius = '8px';
        instructions.style.fontFamily = 'Arial, sans-serif';
        instructions.style.fontSize = '14px';
        instructions.style.zIndex = '1000';
        instructions.style.userSelect = 'none';
        instructions.innerHTML = `
            <strong>Knight's Animation Demo</strong><br><br>
            <b>A/D</b> or <b>Arrow Keys</b>: Move left/right<br>
            <b>W</b> or <b>Up Arrow</b>: Jump<br>
            <b>Shift</b>: Run<br>
            <b>Space</b>: Attack<br>
            <b>Ctrl+D</b>: Toggle debug view<br>
            <b>Ctrl+R</b>: Reset player
        `;
        document.body.appendChild(instructions);
    } catch (error) {
        console.error('Error initializing game:', error);
        
        // Show error message on screen
        gameState.ctx.fillStyle = '#000';
        gameState.ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
        gameState.ctx.fillStyle = '#f00';
        gameState.ctx.font = '20px Arial';
        gameState.ctx.textAlign = 'center';
        gameState.ctx.fillText('Error loading game:', gameState.canvas.width / 2, gameState.canvas.height / 2 - 20);
        gameState.ctx.fillText(error.message, gameState.canvas.width / 2, gameState.canvas.height / 2 + 10);
        gameState.ctx.textAlign = 'left';
    }
}

// Game loop
function gameLoop(timestamp) {
    // Calculate delta time (cap at 100ms to prevent huge jumps after tab switch)
    const deltaTime = Math.min(timestamp - gameState.lastTime, 100);
    gameState.lastTime = timestamp;
    
    // Track FPS
    gameState.frameCount++;
    if (timestamp - gameState.lastFpsUpdateTime >= FPS_UPDATE_INTERVAL) {
        gameState.fps = Math.round((gameState.frameCount * 1000) / (timestamp - gameState.lastFpsUpdateTime));
        gameState.frameCount = 0;
        gameState.lastFpsUpdateTime = timestamp;
    }
    
    // Clear canvas
    gameState.ctx.clearRect(0, 0, gameState.canvas.width, gameState.canvas.height);
    
    // Update world
    gameState.world.update(deltaTime, gameState.player);
    
    // Update player
    gameState.player.update(deltaTime, gameState.keys, gameState.world);
    
    // Check attacks
    combat.checkAttacks(gameState.player, []);
    
    // Draw world
    gameState.world.draw(gameState.ctx);
    
    // Draw player
    gameState.player.draw(gameState.ctx, gameState.world.cameraX, gameState.world.cameraY);
    
    // Update UI with current animation state
    ui.updatePlayerStats(gameState.player);
    
    // Draw debug info if enabled
    if (window.DEBUG_SHOW_FRAMES) {
        gameState.ctx.fillStyle = 'rgba(0,0,0,0.7)';
        gameState.ctx.fillRect(10, 10, 350, 210);
        gameState.ctx.fillStyle = 'white';
        gameState.ctx.font = '14px Arial';
        
        // Animation info
        const currentAnim = gameState.player.animationManager.currentAnimation;
        const currentAnimObj = gameState.player.animationManager.animations[currentAnim];
        
        gameState.ctx.fillText(`Animation: ${currentAnim || 'none'}`, 20, 30);
        
        if (currentAnimObj) {
            gameState.ctx.fillText(`Frame: ${currentAnimObj.frameIndex + 1}/${currentAnimObj.frameCount}`, 20, 50);
            gameState.ctx.fillText(`Sprite Width: ${Math.floor(currentAnimObj.spritesheet.frameWidth)}px`, 20, 70);
            gameState.ctx.fillText(`Time: ${Math.floor(currentAnimObj.timeSinceLastFrame)}/${currentAnimObj.frameDuration}ms`, 20, 90);
            gameState.ctx.fillText(`Loop: ${currentAnimObj.loop ? 'Yes' : 'No'} | Finished: ${currentAnimObj.finished}`, 20, 110);
        }
        
        // Player state
        gameState.ctx.fillText(`Position: (${Math.floor(gameState.player.x)}, ${Math.floor(gameState.player.y)})`, 20, 130);
        gameState.ctx.fillText(`Velocity: (${gameState.player.velocityX.toFixed(1)}, ${gameState.player.velocityY.toFixed(1)})`, 20, 150);
        gameState.ctx.fillText(`Jump: ${gameState.player.isJumping} | Ground: ${gameState.player.isGrounded}`, 20, 170);
        gameState.ctx.fillText(`Jump Started: ${gameState.player.jumpStarted} | Apex: ${gameState.player.jumpApex}`, 20, 190);
        gameState.ctx.fillText(`FPS: ${gameState.fps} | Locked: ${gameState.player.animationManager.locked}`, 20, 210);
    }
    
    // Continue loop
    if (gameState.running) {
        requestAnimationFrame(gameLoop);
    }
}

// Set up input handlers
function setupInputHandlers() {
    // Keyboard events
    window.addEventListener('keydown', (e) => {
        switch (e.key.toLowerCase()) {
            case 'a':
            case 'arrowleft':
                gameState.keys.left = true;
                break;
            case 'd':
            case 'arrowright':
                gameState.keys.right = true;
                break;
            case 'w':
            case 'arrowup':
                gameState.keys.up = true;
                break;
            case 's':
            case 'arrowdown':
                gameState.keys.down = true;
                break;
            case ' ':
                gameState.keys.attack = true;
                e.preventDefault(); // Prevent space from scrolling the page
                break;
            case 'shift':
                gameState.keys.shift = true;
                break;
            case 'd': // Debug toggle (only on keydown to avoid toggle issues)
                if (e.ctrlKey || e.metaKey) {
                    window.DEBUG_SHOW_FRAMES = !window.DEBUG_SHOW_FRAMES;
                    console.log(`Debug mode: ${window.DEBUG_SHOW_FRAMES ? 'ON' : 'OFF'}`);
                }
                break;
            case 'r': // Reset player position
                if (e.ctrlKey || e.metaKey) {
                    const bounds = gameState.world.getBounds();
                    gameState.player.x = Math.floor(gameState.canvas.width / 2) - 32;
                    gameState.player.y = bounds.bottom - gameState.player.height;
                    gameState.player.velocityY = 0;
                    gameState.player.isJumping = false;
                    gameState.player.isGrounded = true;
                    gameState.player.isAttacking = false;
                    gameState.player.animationManager.unlockAnimation();
                    gameState.player.animationManager.playAnimation('idle');
                }
                break;
        }
    });
    
    window.addEventListener('keyup', (e) => {
        switch (e.key.toLowerCase()) {
            case 'a':
            case 'arrowleft':
                gameState.keys.left = false;
                break;
            case 'd':
            case 'arrowright':
                gameState.keys.right = false;
                break;
            case 'w':
            case 'arrowup':
                gameState.keys.up = false;
                break;
            case 's':
            case 'arrowdown':
                gameState.keys.down = false;
                break;
            case ' ':
                gameState.keys.attack = false;
                break;
            case 'shift':
                gameState.keys.shift = false;
                break;
        }
    });
}

// Initialize the game when DOM is loaded
window.addEventListener('DOMContentLoaded', initGame);

================
File: js/player.js
================
// player.js - Rewritten for better animation handling
class Player {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.width = 64;
      this.height = 64;
      this.speed = 4;
      this.jumpForce = 12;
      this.gravity = 0.6;
      this.velocityX = 0;
      this.velocityY = 0;
      this.isJumping = false;
      this.isGrounded = false;
      this.isAttacking = false;
      this.direction = 1; // 1 for right, -1 for left
      
      // Animation system
      this.animationManager = new AnimationManager();
      
      // Combat cooldowns
      this.attackCooldown = 0;
      this.attackCooldownMax = 500; // milliseconds - slightly longer to match the 4-frame attack
      
      // Animation states
      this.jumpStarted = false;
      this.jumpApex = false;
      
      this.loadAnimations();
    }
  
    async loadAnimations() {
      try {
        // Load main sprite sheets (simplified to focus on the key animations)
        const idleSprite = await utils.loadSpritesheet('sprites/knight/Idle.png', 64, 64);
        const walkSprite = await utils.loadSpritesheet('sprites/knight/Walk.png', 64, 64);
        const runSprite = await utils.loadSpritesheet('sprites/knight/Run.png', 64, 64);
        const jumpSprite = await utils.loadSpritesheet('sprites/knight/Jump.png', 64, 64);
        
        // Only load Attack1 as requested for simplification
        const attackSprite = await utils.loadSpritesheet('sprites/knight/Attack1.png', 64, 64);
        
        // Create animations with proper frame counts from sprites
        this.animationManager.addAnimation('idle', new Animation(idleSprite, idleSprite.frameCount, 200));
        this.animationManager.addAnimation('walk', new Animation(walkSprite, walkSprite.frameCount, 100));
        this.animationManager.addAnimation('run', new Animation(runSprite, runSprite.frameCount, 80));
        
        // Jump animation (6 frames: preparation, rising, apex, falling, pre-landing, landing)
        this.animationManager.addAnimation('jump', new Animation(jumpSprite, jumpSprite.frameCount, 150, false));
        
        // Attack animation (4 frames, not looping) - just using Attack1 now
        // Slightly longer duration for attack frames to make them more visible
        this.animationManager.addAnimation('attack', new Animation(attackSprite, attackSprite.frameCount, 120, false));

        // Set initial animation
        this.animationManager.playAnimation('idle');
        
      } catch (error) {
        console.error('Error loading player animations:', error);
      }
    }
  
    update(deltaTime, keys, world) {
      // Update cooldowns
      if (this.attackCooldown > 0) {
        this.attackCooldown -= deltaTime;
      }
  
      // ATTACK HANDLING - simplified to just use Attack1
      // Check for attack initiation
      if (keys.attack && !this.isAttacking && this.attackCooldown <= 0 && this.isGrounded) {
        this.isAttacking = true;
        this.attackCooldown = this.attackCooldownMax;
        this.velocityX = 0; // Stop movement during attack
        
        // Play the attack animation (just using Attack1 now)
        this.animationManager.playAnimation('attack');
        
        // Lock animation until attack finishes
        this.animationManager.lockAnimation();
      }
      
      // Reset X velocity at start of each update
      this.velocityX = 0;
  
      // MOVEMENT HANDLING (only if not attacking)
      if (!this.isAttacking) {
        // Handle left/right movement
        if (keys.left) {
          this.velocityX = -this.speed;
          this.direction = -1;
          
          if (keys.shift) {
            this.velocityX = -this.speed * 1.5;
            if (this.isGrounded && !this.isJumping) {
              this.animationManager.playAnimation('run');
            }
          } else if (this.isGrounded && !this.isJumping) {
            this.animationManager.playAnimation('walk');
          }
        } 
        else if (keys.right) {
          this.velocityX = this.speed;
          this.direction = 1;
          
          if (keys.shift) {
            this.velocityX = this.speed * 1.5;
            if (this.isGrounded && !this.isJumping) {
              this.animationManager.playAnimation('run');
            }
          } else if (this.isGrounded && !this.isJumping) {
            this.animationManager.playAnimation('walk');
          }
        } 
        else if (this.isGrounded && !this.isJumping) {
          // If not moving and on ground, play idle
          this.animationManager.playAnimation('idle');
        }
  
        // JUMP HANDLING
        if (keys.up && this.isGrounded && !this.isJumping) {
          this.velocityY = -this.jumpForce;
          this.isJumping = true;
          this.isGrounded = false;
          this.jumpStarted = true;
          this.jumpApex = false;
          
          // Start with jump animation and lock it to prevent interruption
          this.animationManager.playAnimation('jump');
          // Don't completely lock the animation as we need to control it manually
          // But we could add a partial lock here if needed
        }
      }
  
      // JUMP ANIMATION CONTROL - properly handling all 6 frames
      if (this.isJumping && this.animationManager.currentAnimation === 'jump') {
        const jumpAnim = this.animationManager.animations['jump'];
        
        if (jumpAnim) {
          // Control jump animation frames based on vertical velocity and jump phase
          // Frame 0: Initial crouch/preparation
          // Frames 1-2: Rising
          // Frame 3: Apex/peak of jump
          // Frames 4-5: Falling/landing
          
          if (this.jumpStarted && !this.jumpApex) {
            // Calculate which frame to show based on upward velocity
            if (this.velocityY < -8) {
              jumpAnim.frameIndex = 0; // Initial crouch/preparation
            } else if (this.velocityY < -4) {
              jumpAnim.frameIndex = 1; // Early rise
            } else if (this.velocityY < 0) {
              jumpAnim.frameIndex = 2; // Late rise
            } else {
              // Reached apex of jump
              jumpAnim.frameIndex = 3; 
              this.jumpApex = true;
            }
          } else if (this.jumpApex) {
            // Calculate which frame to show based on downward velocity
            if (this.velocityY < 4) {
              jumpAnim.frameIndex = 3; // Still near apex
            } else if (this.velocityY < 8) {
              jumpAnim.frameIndex = 4; // Early falling
            } else {
              jumpAnim.frameIndex = 5; // Fast falling/pre-landing
            }
          }
          
          // Lock frame in place until next update
          jumpAnim.timeSinceLastFrame = 0;
        }
      }
  
      // Apply physics
      this.velocityY += this.gravity; // Apply gravity
      this.x += this.velocityX;       // Apply X movement
      this.y += this.velocityY;       // Apply Y movement
  
      // COLLISION HANDLING
      const bounds = world.getBounds();
  
      // Check horizontal boundaries
      if (this.x < bounds.left) {
        this.x = bounds.left;
      }
      if (this.x + this.width > bounds.right) {
        this.x = bounds.right - this.width;
      }
  
      // Check ground collision
      if (this.y + this.height >= bounds.bottom) {
        this.y = bounds.bottom - this.height;
        
        // Landing logic
        if (this.isJumping) {
          // Explicitly unlock animation for smooth landing transition
          if (this.animationManager.locked && this.animationManager.currentAnimation === 'jump') {
            this.animationManager.unlockAnimation();
          }
          
          this.isJumping = false;
          
          // Choose appropriate landing animation if not attacking
          if (!this.isAttacking) {
            if (Math.abs(this.velocityX) > 0) {
              if (Math.abs(this.velocityX) > this.speed) {
                this.animationManager.playAnimation('run');
              } else {
                this.animationManager.playAnimation('walk');
              }
            } else {
              this.animationManager.playAnimation('idle');
            }
          }
        }
        
        // Reset jump state
        this.isGrounded = true;
        this.velocityY = 0;
        this.jumpStarted = false;
        this.jumpApex = false;
      }
  
      // Update animation manager
      this.animationManager.update(deltaTime);
  
      // Check if attack animation is finished
      if (this.isAttacking && this.animationManager.isFinished()) {
        // Reset attack state
        this.isAttacking = false;
        this.animationManager.unlockAnimation();
        
        // Return to appropriate animation based on current state
        if (this.isJumping) {
          // If somehow we attacked during a jump (shouldn't happen now), return to jump animation
          this.animationManager.playAnimation('jump');
        } else if (Math.abs(this.velocityX) > 0) {
          // If moving, play walk or run based on speed
          if (Math.abs(this.velocityX) > this.speed) {
            this.animationManager.playAnimation('run');
          } else {
            this.animationManager.playAnimation('walk');
          }
        } else if (this.isGrounded) {
          // Standing still on ground, return to idle
          this.animationManager.playAnimation('idle');
        }
      }
    }
  
    draw(ctx, cameraX, cameraY) {
      // Calculate screen position with camera offset
      const screenX = this.x - cameraX;
      const screenY = this.y - cameraY;
      
      // Draw the player's current animation
      this.animationManager.draw(ctx, screenX, screenY, this.direction === -1);
      
      // Draw hitbox for debugging
      if (window.DEBUG_SHOW_FRAMES) {
        const hitbox = this.getHitbox();
        ctx.strokeStyle = 'lime';
        ctx.lineWidth = 1;
        ctx.strokeRect(
          hitbox.x - cameraX,
          hitbox.y - cameraY,
          hitbox.width,
          hitbox.height
        );
      }
    }
  
    getHitbox() {
      return {
        x: this.x + 16, // Adjust hitbox to be a bit smaller than sprite
        y: this.y + 16,
        width: this.width - 32,
        height: this.height - 16
      };
    }
  
    getAttackHitbox() {
      const hitbox = this.getHitbox();
      // Extend hitbox in direction player is facing
      if (this.direction === 1) {
        hitbox.width += 30;
      } else {
        hitbox.x -= 30;
        hitbox.width += 30;
      }
      return hitbox;
    }
}

================
File: js/ui.js
================
// Simplified UI
const ui = {
    init: function(player) {
        this.messageQueue = [];
        this.messageTimeout = null;
        
        // Create a simple message display
        const messageDisplay = document.createElement('div');
        messageDisplay.id = 'message-display';
        messageDisplay.style.position = 'absolute';
        messageDisplay.style.bottom = '20px';
        messageDisplay.style.left = '50%';
        messageDisplay.style.transform = 'translateX(-50%)';
        messageDisplay.style.color = 'white';
        messageDisplay.style.fontFamily = 'Arial';
        messageDisplay.style.fontSize = '18px';
        messageDisplay.style.textAlign = 'center';
        document.body.appendChild(messageDisplay);
        
        // Create animation name display
        const animDisplay = document.createElement('div');
        animDisplay.id = 'animation-display';
        animDisplay.style.position = 'absolute';
        animDisplay.style.top = '100px';
        animDisplay.style.right = '20px';
        animDisplay.style.background = 'rgba(0,0,0,0.5)';
        animDisplay.style.color = 'white';
        animDisplay.style.padding = '10px';
        animDisplay.style.borderRadius = '5px';
        animDisplay.style.fontFamily = 'Arial';
        document.body.appendChild(animDisplay);
    },
    
    updatePlayerStats: function(player) {
        // Update animation display if it exists
        const animDisplay = document.getElementById('animation-display');
        if (animDisplay && player.animationManager) {
            animDisplay.textContent = `Animation: ${player.animationManager.currentAnimation || 'none'}`;
        }
    },
    
    showMessage: function(message) {
        console.log(message);
        
        this.messageQueue.push(message);
        
        if (!this.messageTimeout) {
            this.processMessageQueue();
        }
    },
    
    processMessageQueue: function() {
        if (this.messageQueue.length === 0) {
            this.messageTimeout = null;
            return;
        }
        
        const message = this.messageQueue.shift();
        const messageDisplay = document.getElementById('message-display');
        
        if (messageDisplay) {
            messageDisplay.textContent = message;
            messageDisplay.style.opacity = 1;
            
            // Fade out
            setTimeout(() => {
                messageDisplay.style.transition = 'opacity 1s ease-out';
                messageDisplay.style.opacity = 0;
            }, 2000);
        }
        
        this.messageTimeout = setTimeout(() => {
            this.processMessageQueue();
        }, 3000);
    }
};

================
File: js/utils.js
================
// utils.js - Complete file
const utils = {
    distance: function(x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    },
  
    randomInt: function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    },
  
    loadImage: function(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => {
          console.warn(`Failed to load image: ${src}, creating placeholder`);
  
          // Create a placeholder canvas
          const canvas = document.createElement("canvas");
          canvas.width = 64;
          canvas.height = 64;
          const ctx = canvas.getContext("2d");
  
          // Draw placeholder pattern
          ctx.fillStyle = "#FF00FF"; // Magenta to indicate missing texture
          ctx.fillRect(0, 0, 64, 64);
          ctx.fillStyle = "#000000";
          ctx.font = "10px Arial";
          ctx.fillText("Missing", 10, 30);
          ctx.fillText("Texture", 10, 45);
  
          resolve(canvas);
        };
        img.src = src;
      });
    },
  
    // Completely rewritten sprite sheet loading function
    loadSpritesheet: function(src, frameWidth, frameHeight) {
      return this.loadImage(src).then((image) => {
        // If the image is a placeholder (canvas), create a basic structure
        if (image instanceof HTMLCanvasElement) {
          return {
            image: image,
            frameWidth: frameWidth,
            frameHeight: frameHeight,
            frameCount: 1
          };
        }

        // Animation frame counts - updated based on actual sprite sheets
        const animationFrameCounts = {
          "Walk.png": 8,     // Correct: 8 frames
          "Attack1.png": 5,  // Updated: 4 frames
          "Attack2.png": 4,  // Assuming similar to Attack1
          "Attack3.png": 4,  // Assuming similar to Attack1
          "Idle.png": 4,     // Correct: 4 frames 
          "Run.png": 7,      // Updated: 7 frames
          "RunAttack.png": 6, // Correct: 6 frames
          "Jump.png": 6,      // Correct: 6 frames
          "Dead.png": 6,      // Correct: 6 frames
          "Hurt.png": 2,      // Correct: 2 frames
          "Defend.png": 5,    // Updated: 5 frames
          "Protect.png": 5    // Assuming similar to Defend
        };

        // Find the matching animation type for this file
        let frameCount = 0;
        let animationType = "";
        for (const [animType, count] of Object.entries(animationFrameCounts)) {
          if (src.includes(animType)) {
            frameCount = count;
            animationType = animType;
            break;
          }
        }
        
        // Fallback if no specific animation type is detected
        if (frameCount === 0) {
          console.warn(`Unknown animation type for ${src}, guessing frameCount`);
          frameCount = Math.floor(image.width / frameWidth);
        }

        // Calculate the width of each frame - THIS IS CRITICAL
        const exactFrameWidth = image.width / frameCount;
        
        console.log(`Loaded ${src}: ${frameCount} frames, image width=${image.width}px, each frame=${exactFrameWidth}px`);

        // Build the spritesheet object with all the necessary properties
        return {
          image: image,
          frameWidth: exactFrameWidth,
          frameHeight: frameHeight,
          frameCount: frameCount,
          animationType: animationType,
          totalWidth: image.width,
          totalHeight: image.height
        };
      });
    }
};

================
File: js/world.js
================
class World {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.tileSize = 32;
        
        // Camera
        this.cameraX = 0;
        this.cameraY = 0;
        this.cameraWidth = 800;
        this.cameraHeight = 600;
        
        // Define ground level
        this.groundLevel = Math.floor(this.height * 0.75);
    }
    
    update(deltaTime, player) {
        // Update camera to follow player
        this.updateCamera(player);
    }
    
    updateCamera(player) {
        // Center camera on player
        this.cameraX = player.x + player.width / 2 - this.cameraWidth / 2;
        
        // Offset the camera vertically to show more of what's above the player
        const verticalOffset = this.cameraHeight * 0.35; // Show more above than below
        this.cameraY = player.y + player.height / 2 - this.cameraHeight / 2 + verticalOffset;
        
        // Clamp camera to world bounds
        this.cameraX = Math.max(0, Math.min(this.width - this.cameraWidth, this.cameraX));
        this.cameraY = Math.max(0, Math.min(this.height - this.cameraHeight, this.cameraY));
    }
    
    draw(ctx) {
        // Set camera dimensions to canvas size
        this.cameraWidth = ctx.canvas.width;
        this.cameraHeight = ctx.canvas.height;
        
        // Draw sky background
        const gradient = ctx.createLinearGradient(0, 0, 0, this.cameraHeight);
        gradient.addColorStop(0, '#87CEEB'); // Sky blue at top
        gradient.addColorStop(1, '#BFEFFF'); // Lighter blue at bottom
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, this.cameraWidth, this.cameraHeight);
        
        // Draw ground
        const groundY = this.groundLevel - this.cameraY;
        ctx.fillStyle = '#5DBB63'; // Green for grass
        ctx.fillRect(0, groundY, this.cameraWidth, this.cameraHeight - groundY);
        
        // Draw a line at the ground level for clarity
        ctx.strokeStyle = '#3A7D44';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, groundY);
        ctx.lineTo(this.cameraWidth, groundY);
        ctx.stroke();
    }
    
    getBounds() {
        return {
            left: 0,
            top: 0,
            right: this.width,
            bottom: this.groundLevel
        };
    }
}

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knight's Animation Demo</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: #000;
        }
        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>
    
    <script src="js/utils.js"></script>
    <script src="js/animation.js"></script>
    <script src="js/player.js"></script>
    <script src="js/world.js"></script>
    <script src="js/combat.js"></script>
    <script src="js/inventory.js"></script>
    <script src="js/ui.js"></script>
    <script src="js/main.js"></script>
</body>
</html>

================
File: styles.css
================
body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #333;
    font-family: Arial, sans-serif;
}

#game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

#game-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#ui-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
    pointer-events: none;
}

#player-stats {
    position: absolute;
    top: 10px;
    left: 10px;
    background-color: rgba(0, 0, 0, 0.7);
    padding: 10px;
    border-radius: 5px;
    color: white;
    border: 1px solid #666;
}

.stat-container {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
}

.stat-label {
    width: 30px;
    margin-right: 5px;
}

#health-bar, #exp-bar {
    width: 200px;
    height: 15px;
    background-color: #333;
    margin: 5px 0;
    border-radius: 3px;
    border: 1px solid #666;
    overflow: hidden;
}

#health-fill {
    height: 100%;
    width: 100%;
    background-color: #f00;
    border-radius: 3px;
    transition: width 0.3s;
}

#exp-fill {
    height: 100%;
    width: 30%;
    background-color: #0f0;
    border-radius: 3px;
    transition: width 0.3s;
}

#inventory-button {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    pointer-events: auto;
    border: 1px solid #666;
    transition: background-color 0.2s;
}

#inventory-button:hover {
    background-color: rgba(50, 50, 50, 0.7);
}

#chat-box {
    position: absolute;
    bottom: 10px;
    left: 10px;
    width: 300px;
    height: 150px;
    background-color: rgba(0, 0, 0, 0.7);
    border-radius: 5px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    border: 1px solid #666;
}

#chat-messages {
    flex-grow: 1;
    padding: 10px;
    overflow-y: auto;
    color: white;
    font-size: 14px;
}

#chat-input {
    width: calc(100% - 16px);
    padding: 8px;
    border: none;
    border-top: 1px solid #666;
    background-color: rgba(30, 30, 30, 0.7);
    color: white;
    pointer-events: auto;
}

.panel {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 400px;
    height: 350px;
    background-color: rgba(0, 0, 0, 0.8);
    border-radius: 5px;
    padding: 20px;
    color: white;
    z-index: 3;
    pointer-events: auto;
    border: 2px solid #666;
}

#inventory-slots {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px;
    margin-top: 20px;
    max-height: 250px;
    overflow-y: auto;
}

.inventory-slot {
    width: 50px;
    height: 50px;
    background-color: rgba(50, 50, 50, 0.5);
    border: 1px solid #666;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    font-size: 10px;
    text-align: center;
    position: relative;
    transition: background-color 0.2s;
}

.inventory-slot:hover {
    background-color: rgba(80, 80, 80, 0.5);
}

#inventory-close {
    position: absolute;
    bottom: 10px;
    right: 10px;
    padding: 5px 10px;
    background-color: #900;
    border-radius: 3px;
    cursor: pointer;
    transition: background-color 0.2s;
}

#inventory-close:hover {
    background-color: #c00;
}

.hidden {
    display: none;
}

.message {
    margin-bottom: 5px;
    animation: fadeIn 0.3s;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}
